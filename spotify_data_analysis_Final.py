# -*- coding: utf-8 -*-
"""spotify_data_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14rxzljWtxxxZo8J8WkpgLe6uepIMLfcO

## Import Required Libraries

Spotify Data Analysis using Python - Project
By - Debashis Sen
INTRODUCTION
Spotify is a Swedish audio streaming and media services provider founded in April 2006. It is the world's largest music streaming service provider and has over 381 million monthly active users.

In this project, we will explore and quantify data about music and draw valuable insights.

We will perform:

Exploratory Data Analysis (EDA)
Data Visualization
Understanding relationships between song audio features and popularity
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""## Exploring the Dataset"""

sp_tracks = pd.read_csv('/content/tracks.csv')
sp_artists = pd.read_csv('/content/artists.csv')

# Files are available in /content/, no drive mount needed.
print("Data loaded successfully.")

#viewing the tracks data
sp_tracks.head()

#viewing the artists data
sp_artists.head()

"""## Identifying Null Values in the Dataset"""

#checking null in tracks data
pd.isnull(sp_tracks).sum()

#checking null in artists data
pd.isnull(sp_artists).sum()

"""## Dataset Overview: Rows, Columns, Data Types, and Memory Usage"""

#checking info in tracks data
sp_tracks.info()

#checking info in artists data
sp_artists.info()

"""## Extracting Insights from the Dataset through AnalysisðŸ“Š

### 1. Exploring the 10 Least Popular Songs in the Spotify Dataset
"""

a=sp_tracks.sort_values('popularity',ascending=True)[0:10]
a[['name','popularity']]

"""### 2. Descriptive Statistics"""

# descriptive statistics of tracks
sp_tracks.describe().transpose()

"""### 3. Discovering the Top 10 Popular Songs in the Spotify Dataset"""

a=sp_tracks
b=a[a['popularity']>90].sort_values('popularity',ascending=False)[:10]
b[['name','popularity','artists']]

"""### 4. Setting Release Date as the Index Column"""

if 'release_date' in sp_tracks.columns:
    sp_tracks.set_index('release_date', inplace=True)
sp_tracks.index = pd.to_datetime(sp_tracks.index, errors='coerce', format='mixed')
years = sp_tracks.index.year
sp_tracks.head()

"""### 5. Extracting Artist Name from the 18th Row of the Dataset"""

sp_tracks[['artists']].iloc[18]

"""### 6. Converting Song Duration from Milliseconds to Seconds"""

if 'duration_ms' in sp_tracks.columns:
    sp_tracks['duration'] = sp_tracks['duration_ms'].apply(lambda x : round(x/1000))
    sp_tracks.drop('duration_ms', inplace=True, axis=1)
elif 'duration' in sp_tracks.columns and sp_tracks['duration'].max() > 10000:
    sp_tracks['duration'] = sp_tracks['duration'].apply(lambda x : round(x/1000))
sp_tracks.duration.head()

"""### 7. Visualization: Pearson Correlation Heatmap for Two Variables"""

import numpy as np

td = sp_tracks.select_dtypes(include='number').corr(method='pearson')

# Create a mask for the upper triangle
mask = np.triu(np.ones_like(td, dtype=bool))

plt.figure(figsize=(12, 8))
# Using a diverging palette for better contrast between positive and negative correlations
hmap = sns.heatmap(td, mask=mask, annot=True, fmt='.2f', cmap='RdBu_r',
                    center=0, linewidths=0.5, linecolor='white')

hmap.set_title('Diagonal Pearson Correlation HeatMap', fontsize=16, fontweight='bold')
plt.xticks(rotation=45, ha='right')
plt.show()

"""### 8. Creating a 4% Sample of the Entire Dataset"""

sample_sp=sp_tracks.sample(int(0.004*len(sp_tracks)))
# Resetting index to avoid duplicate label errors
sample_sp = sample_sp.reset_index()
print(f'Sample size: {len(sample_sp)}')

"""### 9. Regression Plot of Loudness vs. Energy with Regression Line"""

import matplotlib.pyplot as plt
import seaborn as sns

# Using a JointPlot to show the regression along with marginal distributions
g = sns.jointplot(data=sample_sp, x='energy', y='loudness', kind='reg',
                  color='#054907', scatter_kws={'alpha':0.4})

g.fig.suptitle('Joint Regression Plot: Energy vs Loudness', fontsize=14, fontweight='bold', y=1.02)
plt.show()

import ast
from collections import Counter

# Using the previously cleaned 'id_artists_clean' or creating it if missing
if 'id_artists_clean' not in sp_tracks.columns:
    sp_tracks['id_artists_clean'] = sp_tracks['id_artists'].str.strip("[]'\"").str.split(',').str[0]

# Merge tracks with artists to get the genre column
tracks_with_genres = sp_tracks[['id_artists_clean']].merge(
    sp_artists[['id', 'genres']],
    left_on='id_artists_clean',
    right_on='id',
    how='inner'
)

# Explode the genres (handling them as actual lists)
def parse_genres(gen_str):
    try:
        return ast.literal_eval(gen_str)
    except:
        return []

all_genres = []
for g in tracks_with_genres['genres']:
    all_genres.extend(parse_genres(g))

# Count frequencies
genre_counts_total = Counter(all_genres)
genre_df_total = pd.DataFrame(genre_counts_total.items(), columns=['Genre', 'Count']).sort_values('Count', ascending=False)

# Visualization
plt.figure(figsize=(12, 8))
sns.barplot(data=genre_df_total.head(20), x='Count', y='Genre', palette='viridis', hue='Genre', legend=False)
plt.title('Top 20 Genres Across All Tracks', fontsize=16, fontweight='bold')
plt.xlabel('Number of Tracks')
plt.ylabel('Genre')
plt.show()

print(f"Total unique genres found: {len(genre_df_total)}")

import ast
from collections import Counter

# Reuse the artist_details dataframe created in the previous step
# We need to parse the 'genres' column which is currently a string representation of a list
genre_list = []
for genres_str in artist_details['genres']:
    if pd.notnull(genres_str):
        genres = ast.literal_eval(genres_str)
        genre_list.extend(genres)

# Count the frequency of each genre
genre_counts = Counter(genre_list)
genre_df = pd.DataFrame(genre_counts.items(), columns=['Genre', 'Frequency']).sort_values(by='Frequency', ascending=False)

print("Genre Frequency in Top 10 Tracks:")
display(genre_df.head(10))

# Visualization
plt.figure(figsize=(10, 6))
sns.barplot(data=genre_df.head(15), x='Frequency', y='Genre', hue='Genre', palette='magma', legend=False)
plt.title('Most Frequent Genres in Top 10 Hits', fontsize=15, fontweight='bold')
plt.xlabel('Number of Occurrences')
plt.ylabel('Genre')
plt.show()

import ast

# Get the Top 10 tracks
top_10_tracks = sp_tracks.nlargest(10, 'popularity').copy()

# The id_artists column is stored as a string representation of a list
# We extract the first artist ID for each track to perform the lookup
top_10_tracks['primary_artist_id'] = top_10_tracks['id_artists'].apply(lambda x: ast.literal_eval(x)[0])

# Merge with the artists dataframe to get followers and genres
artist_details = top_10_tracks[['name', 'artists', 'primary_artist_id', 'popularity']].merge(
    sp_artists[['id', 'followers', 'genres']],
    left_on='primary_artist_id',
    right_on='id',
    how='left'
)

print("Artist Demographics for the Top 10 Tracks:")
display(artist_details[['name', 'artists', 'followers', 'genres']])

# Visualizing Follower counts
plt.figure(figsize=(10, 6))
sns.barplot(data=artist_details.sort_values('followers', ascending=False), x='followers', y='artists', palette='rocket')
plt.title('Follower Count of Artists behind Top 10 Hits', fontsize=15, fontweight='bold')
plt.xlabel('Number of Followers')
plt.show()

# Extracting detailed features for the Top 10 most popular songs
top_10_detailed = sp_tracks.nlargest(10, 'popularity')[['name', 'artists', 'popularity', 'danceability', 'energy', 'loudness', 'tempo', 'valence']]

print("Detailed Audio Features for Top 10 Most Popular Songs:")
display(top_10_detailed)

# Visualizing the characteristics of these top songs
plt.figure(figsize=(12, 6))
top_10_melted = top_10_detailed.melt(id_vars='name', value_vars=['danceability', 'energy', 'valence'])
sns.barplot(data=top_10_melted, x='value', y='name', hue='variable', palette='magma')
plt.title('Audio Characteristics of the Top 10 Songs', fontsize=15, fontweight='bold')
plt.xlabel('Value (0.0 to 1.0)')
plt.legend(title='Feature', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Creating a unified dashboard to show the entire analysis
fig, axes = plt.subplots(2, 2, figsize=(16, 12))
plt.subplots_adjust(hspace=0.4, wspace=0.3)

# 1. Top 10 Most Popular Songs
top_10 = sp_tracks.nlargest(10, 'popularity')
sns.barplot(ax=axes[0, 0], x='popularity', y='name', data=top_10, hue='name', palette='viridis', legend=False)
axes[0, 0].set_title('Top 10 Most Popular Songs', fontsize=15, fontweight='bold')

# 2. Distribution of Danceability across the dataset
sns.histplot(ax=axes[0, 1], x=sp_tracks['danceability'], bins=30, kde=True, color='teal')
axes[0, 1].set_title('Distribution of Danceability', fontsize=15, fontweight='bold')

# 3. Energy vs Loudness Relationship (using 4% sample)
sns.scatterplot(ax=axes[1, 0], x='energy', y='loudness', data=sample_sp, alpha=0.4, color='darkgreen')
axes[1, 0].set_title('Energy vs Loudness Correlation', fontsize=15, fontweight='bold')

# 4. Average Popularity Trend (2001 - 2021)
recent_data = sp_tracks[sp_tracks.index.year > 2000]
recent_years_avg = recent_data.groupby(recent_data.index.year)['popularity'].mean()
sns.lineplot(ax=axes[1, 1], x=recent_years_avg.index, y=recent_years_avg.values, marker='o', color='firebrick', linewidth=2.5)
axes[1, 1].set_title('Avg. Popularity Trend (2001-2021)', fontsize=15, fontweight='bold')
axes[1, 1].set_xlabel('Year')
axes[1, 1].set_ylabel('Average Popularity')

plt.suptitle('Spotify Dataset Insights Dashboard', fontsize=20, fontweight='bold', y=0.95)
plt.show()

"""### 10. Regression Plot of Popularity vs. Acousticness with Regression Line"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Create categories for acousticness for better bar chart visualization
# We'll reuse the logic to ensure a clear comparison
sample_sp['Acoustic_Category'] = pd.cut(sample_sp['acousticness'], bins=[0, 0.33, 0.66, 1.0], labels=['Low', 'Medium', 'High'])

plt.figure(figsize=(10, 6))
sns.barplot(data=sample_sp, x='Acoustic_Category', y='popularity', hue='Acoustic_Category', palette='YlGnBu', legend=False)

plt.title('Average Popularity by Acousticness Level', fontsize=14, fontweight='bold')
plt.xlabel('Acousticness Level', fontsize=12)
plt.ylabel('Average Popularity', fontsize=12)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# 1. Create simple categories for easier understanding
sample_sp['Acoustic_Level'] = pd.cut(sample_sp['acousticness'],
                                     bins=[0, 0.33, 0.66, 1],
                                     labels=['Low (Electric/Modern)', 'Medium', 'High (Acoustic/Classic)'])

# 2. Create the visualization
plt.figure(figsize=(10, 6))

# Draw a bar plot to show the average popularity for each category
ax = sns.barplot(data=sample_sp, x='Acoustic_Level', y='popularity', hue='Acoustic_Level', palette='Greens', legend=False)

# 3. Add clear labels for beginners
plt.title('How Acousticness Affects Song Popularity', fontsize=15, fontweight='bold')
plt.xlabel('Song Type (Acousticness Level)', fontsize=12)
plt.ylabel('Average Popularity Score', fontsize=12)

# Add explanations on the chart
plt.text(0, sample_sp[sample_sp['Acoustic_Level']=='Low (Electric/Modern)']['popularity'].mean() + 2, 'Most Popular Hits', ha='center', fontweight='bold', color='darkgreen')

plt.tight_layout()
plt.show()

print("This chart shows that songs with 'Low' acousticness (usually modern electronic or produced tracks) tend to have higher average popularity scores compared to highly acoustic tracks.")

"""### 11. Adding a New Column to the Tracks Table"""

sp_tracks['dates']=sp_tracks.index.get_level_values('release_date')
sp_tracks.dates=pd.to_datetime(sp_tracks.dates)
years=sp_tracks.dates.dt.year
sp_tracks.head()

"""### 12. Graph: Number of Songs per Year"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 6))
sns.kdeplot(years, fill=True, color='g', bw_adjust=0.5, alpha=0.6)

plt.title('Song Volume Growth Over Time (Density View)', fontsize=14, fontweight='bold')
plt.xlabel('Year', fontsize=12)
plt.ylabel('Density of Songs', fontsize=12)
plt.show()

"""### 13. Line Graph: Duration of Songs Over Each Year"""

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate average duration per year for a cleaner trend line
yearly_avg_duration = sp_tracks.groupby(years)['duration'].mean()

plt.figure(figsize=(12, 6))
sns.lineplot(x=yearly_avg_duration.index, y=yearly_avg_duration.values, color='blue', linewidth=2)

plt.title('Average Song Duration Over the Years', fontsize=14, fontweight='bold')
plt.xlabel('Year', fontsize=12)
plt.ylabel('Duration (Seconds)', fontsize=12)
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()

"""### 14. Horizontal Bar Plot: Song Duration Across Different Genres"""

# Cleaning the id_artists from sp_tracks to match with the id from sp_artists
sp_tracks['id_artists_clean'] = sp_tracks['id_artists'].str.strip("[]'\"").str.split(',').str[0]

merged_df = sp_tracks.merge(sp_artists[['id', 'genres']], left_on='id_artists_clean', right_on='id')

merged_df.head()

genre_duration = merged_df.groupby('genres')['duration'].sum().sort_values(ascending=False).reset_index()

top_genres = genre_duration.head(10)

import matplotlib.pyplot as plt
import seaborn as sns

# Creating a horizontal bar chart for clear comparison
plt.figure(figsize=(10, 6))
sns.barplot(data=top_genres, x='duration', y='genres', hue='genres', palette='viridis', legend=False)

plt.title('Total Song Duration by Genre', fontsize=15, fontweight='bold')
plt.xlabel('Total Duration (Seconds)', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.tight_layout()
plt.show()

"""### 15. Bar Plot: Top Five Genres by Popularity"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Prepare the data
top_data = merged_df.sort_values('popularity', ascending=False)[:10]
labels = top_data['genres'].values
values = top_data['popularity'].values
num_vars = len(labels)

# Compute angles for each bar
angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()

# Radial plots need to be circular, so we close the loop
values = np.concatenate((values, [values[0]]))
angles = np.concatenate((angles, [angles[0]]))

fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

# Draw the bars
ax.fill(angles, values, color='teal', alpha=0.3)
ax.plot(angles, values, color='teal', linewidth=2)

# Add labels
ax.set_yticklabels([])
ax.set_xticks(angles[:-1])
ax.set_xticklabels(labels, fontsize=10, rotation=45)

plt.title('Top 10 Genres by Popularity (Radial View)', size=16, fontweight='bold', y=1.1)
plt.show()

"""# Task
Extract the top 10 genres by frequency from both the "genre_df" (representing the Top 10 hits) and "genre_df_total" (representing the overall dataset) dataframes, ensuring counts are normalized to percentages for a fair comparison. Create a side-by-side bar chart visualization to compare the dominant genres in the Top 10 hits against those in the entire dataset using the "/content/tracks.csv" and "/content/artists.csv" files. Finally, summarize the key differences found, such as whether modern hits align with the historical dominance of rock or if pop has completely taken over the current landscape.

## Prepare Comparison Data

### Subtask:
Extract the top 10 genres from 'genre_df' and 'genre_df_total', and normalize their frequencies into percentages.

**Reasoning**:
I will calculate the percentage of each genre for both the top 10 tracks and the entire dataset, and then select the top 10 genres from each for comparison.
"""

import pandas as pd

# Calculate percentages for genre_df (Top 10 Hits)
genre_df['Percentage'] = (genre_df['Frequency'] / genre_df['Frequency'].sum()) * 100
top_10_hits_genres = genre_df.nlargest(10, 'Percentage')

# Calculate percentages for genre_df_total (All Tracks)
genre_df_total['Percentage'] = (genre_df_total['Count'] / genre_df_total['Count'].sum()) * 100
top_10_total_genres = genre_df_total.nlargest(10, 'Percentage')

print("Top 10 Genres in Top Hits (Normalized):")
display(top_10_hits_genres[['Genre', 'Frequency', 'Percentage']])

print("\nTop 10 Genres Across All Tracks (Normalized):")
display(top_10_total_genres[['Genre', 'Count', 'Percentage']])

"""## Generate Comparative Visualization

### Subtask:
Create a side-by-side bar chart visualization to compare the top genres of the Top 10 hits against the top genres of the entire dataset.

**Reasoning**:
I will create a side-by-side comparison visualization using two subplots to display the normalized genre frequencies for the top hits versus the entire dataset as specified.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Set up a figure with two side-by-side subplots
fig, axes = plt.subplots(1, 2, figsize=(16, 8))

# Plot 1: Top 10 Genres in Top Hits
sns.barplot(ax=axes[0], data=top_10_hits_genres, x='Percentage', y='Genre', hue='Genre', palette='magma', legend=False)
axes[0].set_title('Top 10 Genres: Top Hits', fontsize=14, fontweight='bold')
axes[0].set_xlabel('Percentage of Total')
axes[0].set_ylabel('Genre')

# Plot 2: Top 10 Genres in All Tracks
sns.barplot(ax=axes[1], data=top_10_total_genres, x='Percentage', y='Genre', hue='Genre', palette='viridis', legend=False)
axes[1].set_title('Top 10 Genres: All Tracks', fontsize=14, fontweight='bold')
axes[1].set_xlabel('Percentage of Total')
axes[1].set_ylabel('Genre')

# Adjust layout and display
plt.tight_layout()
plt.show()

"""## Final Task

### Subtask:
Analyze the results from the previous visualizations and summarize the key differences in genre trends.

## Summary:

### Q&A

**Do modern hits align with the historical dominance of rock, or has pop taken over the current landscape?**
Modern hits show a clear departure from historical trends. While the overall dataset is historically dominated by Rock variants (such as classic rock and album rock), the Top 10 hits are overwhelmingly dominated by Pop. Pop music alone accounts for over 27% of the top hits, indicating it has effectively taken over the current landscape of peak popularity.

### Data Analysis Key Findings

*   **Dominance of Pop in Hits:** In the Top 10 hits dataset, "Pop" is the leading genre, representing approximately **27.27%** of the frequency. Sub-genres like "canadian pop," "post-teen pop," and "dance pop" also figure prominently at **9.09%** each.
*   **Historical Rock Dominance:** Across the entire dataset (representing historical/all tracks), Rock genres are the most frequent. "Rock" leads at **1.97%**, followed by "classic rock" (**1.46%**) and "adult standards" (**1.45%**).
*   **Concentration vs. Diversity:** The Top Hits are highly concentrated in a few genres (the top 10 genres make up a huge portion of the hits), whereas the overall dataset is much more fragmented and diverse, with the top genre accounting for less than **2%** of total tracks.
*   **Genre Evolution:** There is almost no overlap between the Top 10 genres of "All Tracks" and the Top 10 genres of "Top Hits," highlighting a significant shift in listener preferences or industry focus over time.

### Insights or Next Steps

*   **Niche Market Analysis:** Since the overall dataset is highly fragmented with no single genre exceeding 2%, further analysis could be done to identify "rising" genres that have high growth rates even if their total volume is currently low.
*   **Temporal Analysis:** A valuable next step would be to perform a time-series analysis to pinpoint the exact decade or era where Pop overtook Rock as the commercially dominant genre in the "Top Hits" category.

# Task
Analyze the differences in music genre dominance between the "Top 10 Hits" and the overall dataset using the files "/content/tracks.csv" and "/content/artists.csv". Compare the normalized percentages of the top 10 genres from each group to identify significant shifts in listener preferences. Specifically, highlight trend-setting genres like 'canadian pop' and 'dance pop' that appear in the top hits but are statistically minor in the historical data. Conclude with a final overview summarizing how the musical landscape has evolved from the historical dominance of 'Rock' to the current 'Pop' dominated landscape.

## Analyze Genre Differences

### Subtask:
Compare the normalized percentages of the top genres from the Top 10 hits against those from the overall dataset to identify shifts in musical dominance.

**Reasoning**:
I will merge the top genre dataframes for hits and the total dataset to calculate the shift in dominance between modern hits and historical track presence.
"""

import pandas as pd

# Merge the top 10 dataframes on Genre using an outer join
genre_comparison = pd.merge(
    top_10_hits_genres[['Genre', 'Percentage']].rename(columns={'Percentage': 'Top_Hits_%'}),
    top_10_total_genres[['Genre', 'Percentage']].rename(columns={'Percentage': 'All_Tracks_%'}),
    on='Genre',
    how='outer'
)

# Fill missing percentages with 0.0 for direct comparison
genre_comparison = genre_comparison.fillna(0.0)

# Calculate the Dominance Shift
genre_comparison['Dominance_Shift'] = genre_comparison['Top_Hits_%'] - genre_comparison['All_Tracks_%']

# Sort by Dominance Shift descending
genre_comparison = genre_comparison.sort_values(by='Dominance_Shift', ascending=False)

print("Genre Dominance Shift Analysis:")
display(genre_comparison)

"""## Identify Trend-Setters

### Subtask:
Isolate and highlight modern trend-setting genres that are significantly more prominent in the top hits compared to the historical dataset.

**Reasoning**:
I will isolate the specific trend-setting genres and visualize their dominance shift to highlight how they drive the current musical landscape compared to historical data.
"""

import matplotlib.pyplot as plt
import seaborn as sns

# 1. Filter the comparison dataframe for specific trend-setting genres
trend_setting_genres = ['canadian pop', 'dance pop', 'post-teen pop', 'canadian contemporary r&b']
trend_setters_df = genre_comparison[genre_comparison['Genre'].isin(trend_setting_genres)].copy()

# 2. Display the comparison of current vs historical percentages
print("Trend-Setting Genres: Modern Dominance vs. Historical Presence")
display(trend_setters_df[['Genre', 'Top_Hits_%', 'All_Tracks_%', 'Dominance_Shift']])

# 3. Create a specialized visualization for Dominance Shift
plt.figure(figsize=(10, 6))
sns.set_style("whitegrid")
ax = sns.barplot(data=trend_setters_df, x='Dominance_Shift', y='Genre', palette='magma', hue='Genre', legend=False)

# Add labels and title
plt.title('Dominance Shift of Modern Trend-Setting Genres', fontsize=15, fontweight='bold')
plt.xlabel('Percentage Point Increase (Top Hits vs All Tracks)')
plt.ylabel('Genre')

# Annotate the bars with the actual shift value
for i, p in enumerate(ax.patches):
    ax.annotate(f'+{p.get_width():.2f}%', (p.get_width(), p.get_y() + p.get_height() / 2),
                ha='left', va='center', xytext=(5, 0), textcoords='offset points', fontweight='bold')

plt.tight_layout()
plt.show()

# 4. Print summary statement
print(f"Summary: Genres such as {', '.join(trend_setting_genres[:-1])}, and {trend_setting_genres[-1]} are identified as the key drivers of the current musical landscape. Their high dominance shift values confirm they have moved from historical insignificance to being top-tier market leaders.")

"""## Final Task

### Subtask:
Provide a final overview of how listener preferences have evolved from the historical 'Rock' era to the current 'Pop' dominated landscape based on the processed data.

## Summary:

### Q&A

**How have listener preferences evolved from the historical "Rock" era to the current "Pop" dominated landscape?**
The analysis reveals a significant transition where historically dominant genres like 'rock' and 'classic rock' have seen a decline in market share (dropping between 1.45% and 1.97% in relative dominance). In contrast, 'pop' and its sub-genres have surged, now accounting for a substantial portion of top-charting hits despite having a negligible historical footprint in the overall dataset.

### Data Analysis Key Findings

*   **Rise of Pop Dominance**: The 'pop' genre represents **27.27%** of the Top 10 Hits, showing the most significant positive dominance shift compared to the overall historical data.
*   **Emergence of Modern Sub-genres**: Several modern genres that were statistically minor or non-existent in the historical dataset (0.0% footprint) have become market leaders in the Top Hits:
    *   **'dance pop'**, **'canadian pop'**, and **'post-teen pop'** each account for **9.09%** of Top Hits.
    *   **'canadian contemporary r&b'** accounts for **6.06%** of Top Hits.
*   **Decline of Legacy Genres**: Traditional mainstays such as **'rock'**, **'classic rock'**, and **'adult standards'** exhibited the largest negative dominance shifts, indicating they no longer drive the highest-charting hits relative to their historical volume.
*   **Concentrated Trend-Setting**: The current musical landscape is heavily influenced by specific regional and stylistic sub-genresâ€”particularly Canadian-origin pop and R&Bâ€”which have moved from historical insignificance to being top-tier market drivers.

### Insights or Next Steps

*   **Regional Influence**: The strong presence of 'canadian pop' and 'canadian contemporary r&b' suggests that geographical hotspots are significantly influencing global top-charting trends; further analysis into the "origin" metadata of artists could confirm this regional shift.
*   **Sub-genre Granularity**: Future analysis should investigate whether the decline in 'Rock' is a total loss of interest or a fragmentation into niche sub-genres that do not individually reach the "Top 10" threshold as effectively as unified 'Pop' categories.

# Task
Analyze the defining characteristics of the 'pop' genre by filtering the dataset for tracks associated with artists tagged as 'pop' using "/content/tracks.csv" and "/content/artists.csv". Calculate the mean and distribution of audio features like 'danceability', 'energy', 'valence', and 'tempo' for this subset, and visualize the evolution of pop track popularity and frequency over the years. Conclude by summarizing these traits and explaining how they contribute to the genre's massive commercial success.

## Filter Pop Genre Tracks

### Subtask:
Filter the dataset to create a subset containing only tracks associated with the 'pop' genre.

**Reasoning**:
I will filter the artists for those that have 'pop' in their genre list and then merge this with the tracks dataframe to create the 'pop_tracks' subset as requested.
"""

import ast

# 1. Identify artists with the exact 'pop' genre
def contains_exact_pop(genre_str):
    try:
        genres = ast.literal_eval(genre_str)
        return 'pop' in genres
    except:
        return False

pop_artists_ids = sp_artists[sp_artists['genres'].apply(contains_exact_pop)]['id']

# 2. Ensure 'id_artists_clean' exists in tracks for merging
if 'id_artists_clean' not in sp_tracks.columns:
    sp_tracks['id_artists_clean'] = sp_tracks['id_artists'].str.strip("[]'").str.split(',').str[0]

# 3. Filter tracks associated with these 'pop' artists
pop_tracks = sp_tracks[sp_tracks['id_artists_clean'].isin(pop_artists_ids)].copy()

# 4. Display results
print(f'Total tracks found with exact \'pop\' genre: {len(pop_tracks)}')
display(pop_tracks.head())